package org.commcare.android.util;

import org.commcare.android.logic.GlobalConstants;
import org.spongycastle.jce.provider.BouncyCastleProvider;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.X509EncodedKeySpec;

/**
 * A set of helper methods for verifying whether a message was genuinely sent from HQ
 *
 * Created by wpride1 on 9/11/15.
 */
public class SigningUtil {
    /**
     *
     * @param text the parsed out text message in the expected link/signature format
     * @return the download link if the message was valid and verified, null otherwise
     * @throws SignatureException if we discovered a valid-looking message but could not verifyMessageSignatureHelper it
     */
    public static String parseAndVerifySMS(String text) throws SignatureException {
        // parse out the app link and signature. We assume there is a space after ccapp: and
        // signature: and that the end of the signature is the end of the text content

        String decodedMessage = SigningUtil.decodeEncodedSMS(text);
        String[] parsedMessage = SigningUtil.parseDecodedSMS(decodedMessage);
        if(verifySMS(parsedMessage[0], parsedMessage[1])){
            return parsedMessage[1];
        }
        throw new SignatureException();
    }

    private static boolean verifySMS(String signature, String message){
        String keyString = GlobalConstants.CCHQ_PUBLIC_KEY;
        return SigningUtil.verifyMessageSignatureHelper(keyString, message, signature);
    }
    /**
     *
     * @param publicKeyString the known public key of CCHQ
     * @param message the message content
     * @param messageSignature the signature generated by HQ with its private key and the message content
     * @return whether or not the message was verified to be sent with HQ's private key
     */
    public static boolean verifyMessageSignatureHelper(String publicKeyString, String message, String messageSignature) {
        try {
            PublicKey publicKey = getPublicKey(publicKeyString);
            return verifyMessageSignature(publicKey, message, messageSignature);
        } catch (Exception e) {
            // a bunch of exceptions can be thrown from the crypto methods. I mostly think we just
            // care that we couldn't verify it
            e.printStackTrace();
        }
        return false;
    }

    private static PublicKey getPublicKey(String key) throws Exception{
        byte[] derPublicKey = Base64.decode(key);
        X509EncodedKeySpec spec = new X509EncodedKeySpec(derPublicKey);
        KeyFactory kf = KeyFactory.getInstance("RSA");
        return kf.generatePublic(spec);
    }

    private static boolean verifyMessageSignature(PublicKey publicKey, String messageString, String signature) throws SignatureException, NoSuchAlgorithmException, Base64DecoderException, InvalidKeyException {
        Signature sign = Signature.getInstance("SHA256withRSA/PSS", new BouncyCastleProvider());
        byte[] signature_binary = Base64.decode(signature);
        byte[] message = messageString.getBytes();
        sign.initVerify(publicKey);
        sign.update(message);
        return sign.verify(signature_binary);
    }

    private static String decodeEncodedSMS(String text) throws  SignatureException{
        String base64Message = text.substring(text.indexOf(GlobalConstants.SMS_INSTALL_KEY_STRING) +
                GlobalConstants.SMS_INSTALL_KEY_STRING.length() + 1);
        String decodedMessage = null;
        try {
            decodedMessage = new String(Base64.decode(base64Message), "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            throw new SignatureException();
        } catch (Base64DecoderException e) {
            e.printStackTrace();
            throw new SignatureException();
        }
        return decodedMessage;

    }

    public static String[] parseDecodedSMS(String decodedMessage){
        String downloadLink = decodedMessage.substring(decodedMessage.indexOf("ccapp:") + 7,
                decodedMessage.indexOf(","));
        String signature = decodedMessage.substring(decodedMessage.indexOf("signature:") + 11);
        return new String[] {downloadLink, signature};
    }
}
